# #!/usr/bin/ruby
snippet #!
	#!/usr/bin/ruby
# New Block
snippet =b
	=begin rdoc
		${1}
	=end
snippet y
	:yields: ${1:arguments}
snippet rb
	#!/usr/bin/env ruby -w
snippet req
	require "${1}"${2}
snippet #
	# =>
snippet end
	__END__
snippet case
	case ${1:object}
	when ${2:condition}
		${3}
	end
snippet when
	when ${1:condition}
		${2}
snippet def
	def ${1:method_name}
		${2}
	end
snippet defi
	def initialize(${1:args})
		${2}
	end
snippet if
	if ${1:condition}
		${2}
	end
snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	end
snippet elsif
	elsif ${1:condition}
		${2}
snippet unless
	unless ${1:condition}
		${2}
	end
snippet while
	while ${1:condition}
		${2}
	end
snippet until
	until ${1:condition}
		${2}
	end
snippet cla class .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end
snippet mod module .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end
# attr_reader
snippet r
	attr_reader :${1:attr_names}
# attr_writer
snippet w
	attr_writer :${1:attr_names}
# attr_accessor
snippet rw
	attr_accessor :${1:attr_names}
# include Enumerable
snippet enum
	include Enumerable

	def each(&block)
		${1}
	end
# include Comparable
snippet comp
	include Comparable

	def <=>(other)
		${1}
	end
# def method_missing
snippet defmm
	def method_missing(meth, *args, &blk)
		${1}
	end
snippet am
	alias_method :${1:new_name}, :${2:old_name}
snippet app
	if __FILE__ == $PROGRAM_NAME
		${1}
	end
snippet zip
	zip(${1:enums}) do |${2:row}| 
		${3}
	end
# loops
snippet down
	downto(${1:0}) do |${2:i}| 
		${3} 
	end
snippet step
	step(${1:2}) do |${2:n}| 
		${3}
	end
snippet times
	times do |${1:n}| 
		${2}
	end
snippet upto
	upto(${1:1.0/0.0}) do |${2:n}| 
		${3}
	end
snippet loop
	loop do 
		${1}
	end
snippet each
	each do |${1:x}| 
		${2}
	end
snippet eab
	each_byte do |${1:byte}| 
		${2}
	end
snippet eac
	each_char do |${1:chr}| 
		${2}
	end
snippet eai
	each_index do |${1:i}| 
		${2}
	end
snippet eak
	each_key do |${1:key}| 
		${2}
	end
snippet eal
	each_line do |${1:line}| 
		${2}
	end
snippet eap
	each_pair do |${1:name}, ${2:val}|
		${3}
	 end
snippet eas
	each_slice(${1:2}) do |${2:group}| 
		${3}
	end
snippet eav
	each_value do |${1:val}| 
		${2}
	end
snippet eawi
	each_with_index do |${1:x}, ${2:i}| 
		${3}
	end
snippet reve
	reverse_each do |${1:x}| 
		${2}
	end
snippet inj
	inject(${1:init}) do |${2:t}, ${3:var}| 
		${4}
	end
snippet map
	map do |${1:x}| 
		${2} 
	end
snippet mapwi
	enum_with_index.map do |${1:x}, ${2:i}| 
		${3}
	end
snippet sort
	sort do |a, b| 
		${1}
	end
snippet sorb
	sort_by do |${1:x}| 
		${2}
	 nd
snippet rand
	sort_by { rand }
snippet all
	all? do |${1:x}| 
		${2}
	end
snippet any
	any? do |${1:x}| 
		${2}
	end
snippet cl
	classify do |${1:x}| 
		${2}
	end
snippet col
	collect do |${1:x}| 
		${2}
	end
snippet det
	detect do |${1:x}| 
		${2}
	end
snippet fet
	fetch(${1:name}) do |${2:key}| 
		${3}
	end
snippet find
	find do |${1:x}| 
		${2}
	end
snippet fina
	find_all do |${1:x}| 
		${2}
	end
snippet grep
	grep(${1:/pattern/}) { |${2:match}| ${3} }
snippet sub
	${1:g}sub(${2:/pattern/}) { |${3:match}| ${4} }
snippet scan
	scan(${1:/pattern/}) { |${2:match}| ${3} }
snippet max
	max do |a, b| 
		${1}
	end
snippet min
	min do |a, b| 
		${1}
	end
snippet par
	partition do |${1:x}| 
		${2}
	end
snippet rej
	reject do |${1:x}| 
		${2}
	end
snippet sel
	select do |${1:x}| 
		${2}
	end
snippet lam
	lambda do |${1:args}| 
		${2}
	end
snippet do
	do |${1:variable}|
		${2}
	end
snippet open
	open(${1:"path/or/url/or/pipe"}, "${2:w}") { |${3:io}| ${4} }
# unix_filter {}
snippet unif
	ARGF.each_line${1} do |${2:line}|
		${3}
	end
# relative paths in a portable way
snippet relpa
	File.join(File.dirname(__FILE__), "${1:../whatever}")${2}
snippet relq
	require File.join(File.dirname(__FILE__), "${1:../whatever}")${2}
# option_parse {}
snippet optp
	require "optparse"

	options = {${1:default => "args"}}

	ARGV.options do |opts|
		opts.banner = "Usage: #{File.basename($PROGRAM_NAME)}
snippet opt
	opts.on( "-${1:o}", "--${2:long-option-name}", ${3:String},
	         "${4:Option description.}") do |${5:opt}|
		${6}
	end
# testing
snippet des
	describe "${1:description}" do
		${2}
	end
snippet desc
	describe ${1:class} do
		${2}
	end
snippet descd
	describe ${1:class} "${2:description}" do
		${3}
	end
snippet it
	it "should ${1:desc}" do
		${2}
	end
snippet itsh
	it "should ${1:desc}" do
		${2:model}.should ${3}
	end
snippet itshn
	it "should not ${1:desc}" do
		${2:model}.should_not ${3}
	end
snippet itshb
	it "should be ${1:desc}" do
		${2:model}.should be_${3:empty}
	end
snippet itshnb
	it "should not be ${1:desc}" do
		${2:model}.should_not be_${3:empty}
	end
snippet con
	context "${1:when}" do
		${2}
	end
snippet bef
	before(:${1:each}) do
		${2}
	end
snippet aft
	after(:${1:each}) do
		${2}
	end
