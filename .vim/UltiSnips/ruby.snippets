# #!/usr/bin/ruby
snippet #!
#!/usr/bin/ruby${1:19} -w
endsnippet

# New Block
snippet =b
=begin ${1:rdoc}
    ${2}
=end
endsnippet

# require
snippet req
require "${1}"
endsnippet

# case
snippet case
case ${1:object}
when ${2:condition}
    ${3}
end
endsnippet

snippet when
when ${1:condition}
    ${2}
endsnippet

# The smart def and smart class snippets use a global option called
# "g:ultisnips_comment_style" which, if set to "doxygen" will use doxygen
# style comments in docstrings.
# Note: stolen from the python snippets :)

global !p
def get_args(arglist, snip):
    args = [arg.split('=')[0].strip() for arg in arglist.split(',') if arg]
    args = [arg for arg in args if arg]
    return args
endglobal

# def
snippet def "def" b
def ${1:method_name}(${2:args})
    ${0}
end
endsnippet

# def initialize
snippet defi "def" b
def initialize(${1:args})`!p
args = get_args(t[1], snip)

snip >> 1
for arg in args:
    snip += "@%s = %s" % (arg, arg)
`
$0
end
endsnippet

##############
# conditions #
##############

# if
snippet if "if" w
if ${1:condition}
    ${2}
end
endsnippet

# if else
snippet ife
if ${1:condition}
    ${2}
else
    ${3}
end
endsnippet

# elsif
snippet elsif
elsif ${1:condition}
    ${2}
endsnippet

# unless
snippet unl "unless" w
unless ${1:condition}
    ${2}
end
endsnippet

#########
# loops #
#########

# while
snippet whi "while" w
while ${1:condition}
    ${2}
end
endsnippet

# until
snippet unt "until" w
until ${1:condition}
    ${2}
end
endsnippet

#########
# class #
#########

# class
snippet cla "class .. end" b
class ${1:`!p snip.rv = snip.basename.title()`}
    ${2}
end
endsnippet

# module
snippet mod "module .. end" b
module ${1:`!p snip.rv = snip.basename.title()`}
    ${2}
end
endsnippet

# attr_reader
snippet r
attr_reader :${1:attr_names}
endsnippet

# attr_writer
snippet w
attr_writer :${1:attr_names}
endsnippet

# attr_accessor
snippet rw
attr_accessor :${1:attr_names}
endsnippet

# include Enumerable
snippet enum
include Enumerable

def each(&block)
    ${1}
end
endsnippet

# include Comparable
snippet comp
include Comparable

def <=>(other)
    ${1}
end
endsnippet

# def method_missing
snippet defmm
def method_missing(meth, *args, &blk)
    ${1}
end
endsnippet

# alias
snippet ali
alias_method :${1:new_name}, :${2:old_name}
endsnippet

########
# each #
########

# zip
snippet zip "zip" w
zip(${1:enums}) do |${2:row}|
    ${3}
end
endsnippet

snippet zipb "zipb" w
zip(${1:enums}) {|${2:row}| ${3} }
endsnippet

# down
snippet down "down" w
downto(${1:0}) do |${2:i}|
    ${3}
end
endsnippet

snippet downb "downb" w
downto(${1:0}) {|${2:i}| ${3} }
endsnippet

# step
snippet step "step" w
step(${1:2}) do |${2:n}|
    ${3}
end
endsnippet

snippet stepb "stepb" w
step(${1:2}) {|${2:i}| ${3} }
endsnippet

# times
snippet times "times" w
times do |${1:n}|
    ${2}
end
endsnippet

snippet timesb "timesb" w
times {|${1:n}| ${2} }
endsnippet

# upto
snippet upto "upto" w
upto(${1:limit}) do |${2:n}|
    ${3}
end
endsnippet

snippet uptob "uptob" w
upto(${1:limit}) { |${2:n}| ${3} }
endsnippet

# loop
snippet loop "loop" w
loop do
    ${1}
end
endsnippet

# each
snippet each "each" w
each do |${1:x}|
    ${2}
end
endsnippet

snippet eachb "eachb" w
each {|${1:x}| $2 }
endsnippet

# each_byte
snippet eab "eab" w
each_byte do |${1:byte}|
    ${2}
end
endsnippet

snippet eabb "eabb" w
each_byte {|${1:byte}| ${2} }
endsnippet

# each_char
snippet eac "eac" w
each_char do |${1:chr}|
    ${2}
end

snippet eacb "eacb" w
each_char {|${1:chr}| ${2} }
endsnippet

# each_index
snippet eai "eai" w
each_index do |${1:i}|
    ${2}
end
endsnippet

snippet eaib "eaib" w
each_index {|${1:i}| ${2} }
endsnippet

# each_key
snippet eak "eak" w
each_key do |${1:key}|
    ${2}
end
endsnippet

snippet eakb "eakb" w
each_key {|${1:key}| ${2} }
endsnippet

# each_line
snippet eal "eal" w
each_line do |${1:line}|
    ${2}
end
endsnippet

snippet ealb "ealb" w
each_line {|${1:line}| ${2} }
endsnippet

# each_pair
snippet eap "eap" w
each_pair do |${1:name}, ${2:val}|
    ${3}
end

snippet eapb "eapb" w
each_pair {|${1:name}, ${2:val} ${3} }
endsnippet

# each_slice
snippet eas "eas" w
each_slice(${1:2}) do |${2:group}|
    ${3}
end
endsnippet

snippet easb "easb" w
each_slice(${1:2}) {|${2:group}| ${3} }
endsnippet

# each_value
snippet eav "eav" w
each_value do |${1:val}|
    ${2}
end
endsnippet

snippet eavb "eavb" w
each_value {|${1:val}| ${2} }
endsnippet

# each_with_index
snippet eawi "eawi" w
each_with_index do |${1:x}, ${2:i}|
    ${3}
end
endsnippet

snippet eawib "eawib" w
each_with_index {|${1:x}, ${2:i}| ${3} }
endsnippet

# reverse_each
snippet rev "rev" w
reverse_each do |${1:x}|
    ${2}
end
endsnippet

snippet revb "revb" w
reverse_each {|${1:x}| ${2} }
endsnippet

# inject
snippet inj "inj" w
inject(${1:init}) do |${2:t}, ${3:var}|
    ${4}
end
endsnippet

snippet injb "injb" w
inject(${1:init}) {|${2:t}, ${3:var}| ${4} }
endsnippet

# map
snippet map "map" w
map do |${1:x}|
    ${2}
end
endsnippet

snippet mapb "mapb" w
map {|${1:x}| ${2} }
endsnippet

# sort
snippet sort "sort" w
sort do |a, b|
    ${1}
end

snippet sortb "sortb" w
sort {|a, b| ${1} }
endsnippet

# sort_by
snippet sob "sob" w
sort_by do |${1:x}|
    ${2}
end
endsnippet

snippet sobb "sobb" w
sort_by {|${1:x}| ${2} }
endsnippet

# randomize
snippet rand "rand" w
sort_by { rand }
endsnippet

# all
snippet all "all" w
all? do |${1:x}|
    ${2}
end
endsnippet

snippet allb "allb" w
all? {|${1:x}| ${2} }
endsnippet

# any
snippet any "any" w
any? do |${1:x}|
    ${2}
end
endsnippet

snippet anyb "anyb" w
any? {|${1:x}| ${2} }
endsnippet

# fetch
snippet fet "fet" w
fetch(${1:name}) do |${2:key}|
    ${3}
end
endsnippet

snippet fetb "fetb" w
fetch(${1:name}) {|${2:key}| ${3} }
endsnippet

# find
snippet find "find" w
find do |${1:x}|
    ${2}
end
endsnippet

snippet find "find" w
find {|${1:x}| ${2} }
endsnippet

# find_all
snippet fina "fina" w
find_all do |${1:x}|
    ${2}
end
endsnippet

snippet finab "finab" w
find_all {|${1:x}| ${2} }
endsnippet

#grep
snippet grep "grep" w
grep(${1:/pattern/}) do |${2:match}|
    ${3}
end
endsnippet

snippet grepb "grepb" w
grep(${1:/pattern/}) {|${2:match}| ${3} }
endsnippet

# (g)sub
snippet sub "sub" w
${1:g}sub(${2:/pattern/}) do |${3:match}|
    ${4}
end
endsnippet

snippet subb "subb" w
${1:g}sub(${2:/pattern/}) {|${3:match}| ${4} }
endsnippet

# scan
snippet scan "scan" w
scan(${1:/pattern/}) do |${2:match}|
    ${3}
end
endsnippet

snippet scanb "scanb" w
scan(${1:/pattern/}) { |${2:match}| ${3} }
endsnippet

# max
snippet max "max" w
max do |a, b|
    ${1}
end
endsnippet

snippet maxb "maxb" w
max {|a, b| ${1} }
endsnippet

# min
snippet min "min" w
min do |a, b|
    ${1}
end
endsnippet

snippet minb "minb" w
min {|a, b| ${1} }
endsnippet

# partition
snippet par "par" w
partition do |${1:x}|
    ${2}
end
endsnippet

snippet parb "parb" w
partition {|${1:x}| ${2} }
endsnippet

# reject
snippet rej "rej" w
reject do |${1:x}|
    ${2}
end
endsnippet

snippet rejb "rejb" w
reject {|${1:x}| ${2} }
endsnippet

# select
snippet sel "sel" w
select do |${1:x}|
    ${2}
end

snippet selb "selb" w
select {|${1:x}| ${2} }
endsnippet

# lambda
snippet lam
lambda do |${1:args}|
    ${2}
end

snippet lamd
lambda {|${1:args}| ${2} }
endsnippet

snippet do
do |${1:variable}|
    ${2}
end
endsnippet

# relative paths in a portable way
snippet relpa
File.join(File.dirname(__FILE__), "${1:../whatever}")${2}
endsnippet

snippet relq
require File.join(File.dirname(__FILE__), "${1:../whatever}")${2}
endsnippet

snippet reql
require File.join(File.dirname(__FILE__), "${1:../whatever}")${2}
endsnippet

# testing
snippet des
describe "${1:description}" do
    ${2}
end
endsnippet

snippet desc
describe ${1:class} do
    ${2}
end
endsnippet

snippet descd
describe ${1:class} "${2:description}" do
    ${3}
end
endsnippet

snippet it
it "should ${1:desc}" do
    ${2}
end
endsnippet

snippet itsh
it "should ${1:desc}" do
    ${2:model}.should ${3}
end
snippet itshn
it "should not ${1:desc}" do
    ${2:model}.should_not ${3}
end
endsnippet

snippet itshb
it "should be ${1:desc}" do
    ${2:model}.should be_${3:empty}
end
endsnippet

snippet itshnb
it "should not be ${1:desc}" do
    ${2:model}.should_not be_${3:empty}
end
endsnippet

snippet con
context "${1:when}" do
    ${2}
end
endsnippet

snippet bef
before(:${1:each}) do
    ${2}
end
endsnippet

snippet aft
after(:${1:each}) do
    ${2}
end
endsnippet
